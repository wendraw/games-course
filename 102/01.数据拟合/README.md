> PPT: [01.数据拟合.pptx](http://staff.ustc.edu.cn/~lgliu/Courses/GAMES102_2020/PPT/GAMES102-1_DataFitting.pdf)
> 视频: [01.数据拟合.mp4](https://www.bilibili.com/video/BV1NA411E7Yr/?share_source=copy_web&vd_source=43929e1eb72edc92ccec94f51d8e77e7)

## 概述

数据拟合是计算机图形学和数值分析中的基础问题，目标是根据给定的数据点找到一个函数来描述或近似这些数据。本项目实现了两种经典的拟合方法：

1. **插值型拟合**：要求拟合函数必须通过所有给定的数据点
2. **逼近型拟合**：允许拟合函数不完全通过数据点，而是寻找最佳的整体拟合效果

## 🎯 使用指南

### 基本操作

1. **添加数据点**：点击画布上的任意位置添加红色数据点
2. **选择拟合类型**：
   - 插值型拟合：精确通过所有点
   - 逼近型拟合：寻找最佳拟合趋势
3. **调整多项式次数**：在逼近型拟合模式下，可以选择 1-5 次多项式
4. **实时观察**：拟合曲线会实时更新显示

### 🧪 实验建议

#### 实验 1：比较不同次数多项式的拟合效果

1. 在画布上添加 6-8 个数据点，形成一个波形
2. 选择"逼近型拟合"
3. 依次尝试 1 次、2 次、3 次、4 次、5 次多项式，观察差异：
   - 1 次：直线拟合，可能无法捕捉曲线特征
   - 2 次：抛物线拟合，适合简单弯曲
   - 3 次：可以处理一个拐点
   - 4 次：可以处理两个拐点
   - 5 次：更复杂的曲线，但可能过拟合

#### 实验 2：插值 vs 逼近的直观对比

1. 添加 4-5 个数据点
2. 先选择"插值型拟合"，观察蓝色曲线精确通过所有点
3. 切换到"逼近型拟合"（2 次），观察绿色曲线的平滑效果
4. 尝试不同次数的逼近拟合，看哪个最接近插值效果

#### 实验 3：噪声数据的处理

1. 添加 6-8 个点，故意让一些点偏离明显的趋势（模拟噪声）
2. 对比插值型拟合和逼近型拟合的表现：
   - 插值型：会严格通过所有点，包括"噪声"点
   - 逼近型：会忽略噪声，找到整体趋势

#### 实验 4：过拟合现象演示

1. 只添加 4 个数据点
2. 选择"逼近型拟合"，尝试 5 次多项式
3. 观察拟合曲线可能出现的剧烈波动
4. 降低到 2 次或 3 次，观察拟合效果的改善

### 💡 数学洞察

通过这些实验，您可以直观地理解：

1. **插值的"完美"与"脆弱"**：

   - 优势：数学上完美，精确通过所有点
   - 劣势：对噪声敏感，高次多项式可能振荡

2. **逼近的"妥协"与"稳健"**：

   - 优势：对噪声鲁棒，可以控制模型复杂度
   - 劣势：不能保证通过所有点

3. **多项式次数的选择**：
   - 次数太低：欠拟合，无法捕捉数据特征
   - 次数太高：过拟合，对训练数据过度适应
   - 最佳选择：在拟合效果和模型复杂度之间平衡

---

## 1. 插值型拟合 - 拉格朗日插值法

### 基本原理

拉格朗日插值法是一种经典的多项式插值方法，其基本思想是：给定 n+1 个不同的数据点 $(x_0, y_0), (x_1, y_1), ..., (x_n, y_n)$，构造一个 n 次多项式 $P(x)$，使得 $P(x_i) = y_i$ 对所有 $i = 0, 1, ..., n$ 成立。

### 数学公式

拉格朗日插值多项式的表达式为：

$$P(x) = \sum_{i=0}^{n} y_i \cdot L_i(x)$$

其中 $L_i(x)$ 是拉格朗日基函数：

$$L_i(x) = \prod_{j=0, j \neq i}^{n} \frac{x - x_j}{x_i - x_j}$$

### 算法步骤

1. **输入**：n+1 个数据点 $(x_i, y_i)$
2. **对于每个插值点 x**：
   - 计算每个拉格朗日基函数 $L_i(x)$
   - 计算加权和 $P(x) = \sum_{i=0}^{n} y_i \cdot L_i(x)$
3. **输出**：插值多项式在点 x 处的值

### 代码实现解析

```javascript
interpolation: (points, x) => {
  if (points.length === 0) return 0
  if (points.length === 1) return points[0].y

  let result = 0
  for (let i = 0; i < points.length; i++) {
    let term = points[i].y // y_i
    for (let j = 0; j < points.length; j++) {
      if (i !== j) {
        const denominator = points[i].x - points[j].x
        if (Math.abs(denominator) < 1e-10) {
          return points[i].y // 避免除零错误
        }
        term *= (x - points[j].x) / denominator // 构造 L_i(x)
      }
    }
    result += term
  }
  return result
}
```

### 特点与应用

**优点**：

- 精确通过所有数据点
- 数学形式简洁优美
- 适用于精确插值需求

**缺点**：

- 随着数据点增多，多项式次数增高，可能出现龙格现象（振荡）
- 对数据中的噪声敏感
- 计算复杂度较高：O(n²)

**适用场景**：

- 数据点较少（通常<10 个）
- 数据精度要求高
- 需要平滑连续的曲线

---

## 2. 逼近型拟合 - 最小二乘法

### 基本原理

最小二乘法的核心思想是寻找一个函数（通常是多项式），使得该函数与所有数据点的误差平方和最小。本实现支持任意次数的多项式拟合，对于 n 次多项式拟合，我们要找到系数 $a_0, a_1, a_2, ..., a_n$ 使得：

$$f(x) = a_n x^n + a_{n-1} x^{n-1} + ... + a_1 x + a_0$$

最小化目标函数：

$$S = \sum_{i=0}^{m} (y_i - f(x_i))^2 = \sum_{i=0}^{m} (y_i - \sum_{j=0}^{n} a_j x_i^j)^2$$

其中 m+1 是数据点的数量，n 是多项式的次数。

### 任意次数多项式的数学推导

为了最小化 $S$，我们对每个系数 $a_k$ 求偏导数并令其为零：

$$\frac{\partial S}{\partial a_k} = -2\sum_{i=0}^{m} x_i^k(y_i - \sum_{j=0}^{n} a_j x_i^j) = 0$$

这给出正规方程组：

$$\sum_{j=0}^{n} a_j \sum_{i=0}^{m} x_i^{j+k} = \sum_{i=0}^{m} x_i^k y_i \quad \text{for } k = 0, 1, ..., n$$

### 矩阵形式

写成矩阵形式：

$$
\begin{bmatrix}
\sum x_i^0 & \sum x_i^1 & \sum x_i^2 & \cdots & \sum x_i^n \\
\sum x_i^1 & \sum x_i^2 & \sum x_i^3 & \cdots & \sum x_i^{n+1} \\
\sum x_i^2 & \sum x_i^3 & \sum x_i^4 & \cdots & \sum x_i^{n+2} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
\sum x_i^n & \sum x_i^{n+1} & \sum x_i^{n+2} & \cdots & \sum x_i^{2n}
\end{bmatrix}
\begin{bmatrix}
a_0 \\ a_1 \\ a_2 \\ \vdots \\ a_n
\end{bmatrix}
=
\begin{bmatrix}
\sum y_i \\
\sum x_i y_i \\
\sum x_i^2 y_i \\
\vdots \\
\sum x_i^n y_i
\end{bmatrix}
$$

### 实现特点

我们的实现支持任意次数的多项式拟合（1-20 次）：

1. **灵活输入**：直接输入数字设置多项式次数
2. **自动验证**：输入范围限制在 1-20 次之间
3. **数值稳定性**：使用高斯消元法求解，包含主元选择
4. **智能降级**：数据点不足或矩阵奇异时自动降级到线性拟合
5. **实时提示**：显示当前次数和所需最少点数

### 多项式次数选择指南

| 次数范围 | 最少点数 | 适用场景                | 注意事项        |
| -------- | -------- | ----------------------- | --------------- |
| 1-2 次   | 2-3      | 简单趋势，线性/二次关系 | 稳定可靠        |
| 3-5 次   | 4-6      | 中等复杂度，多个拐点    | 平衡选择        |
| 6-10 次  | 7-11     | 复杂曲线，精细拟合      | 需要足够数据    |
| 11-20 次 | 12-21    | 极复杂模式，研究用途    | ⚠️ 高过拟合风险 |

### 高次多项式注意事项

**使用高次多项式时需要注意：**

1. **数值稳定性**：

   - 次数越高，系数矩阵越容易变得病态
   - 建议数据点数至少是多项式次数的 2-3 倍

2. **过拟合风险**：

   - 高次多项式可能对训练数据过度拟合
   - 在数据点之间可能出现剧烈振荡

3. **实际应用建议**：

   - 一般情况下，2-5 次已经足够
   - 超过 10 次的多项式很少在实际中使用
   - 考虑使用样条插值代替高次多项式

4. **龙格现象**：
   - 高次多项式在区间边界处可能出现剧烈振荡
   - 这是插值多项式的固有问题

### 代码实现解析

```javascript
// 任意次数多项式最小二乘法拟合
approximation: (points, x) => {
  const degree = parseInt(polynomialDegree.value) || 1
  const n = points.length

  // 检查数据点是否足够
  if (n < degree + 1) {
    return linearFit(points, x) // 降级处理
  }

  // 数值稳定性警告
  if (degree > 10 && n > 50) {
    console.warn('高次多项式拟合可能存在数值稳定性问题')
  }

  // 计算各种x的幂次和 (0 to 2*degree)
  const sums = new Array(2 * degree + 1).fill(0)
  const sumY = new Array(degree + 1).fill(0)

  for (let i = 0; i < n; i++) {
    const xi = points[i].x
    const yi = points[i].y

    // 计算 Σ(x^j) 和 Σ(x^j * y)
    let xPower = 1
    for (let j = 0; j <= 2 * degree; j++) {
      sums[j] += xPower
      xPower *= xi
    }

    xPower = 1
    for (let j = 0; j <= degree; j++) {
      sumY[j] += yi * xPower
      xPower *= xi
    }
  }

  // 构造并求解线性方程组
  const matrix = buildMatrix(sums, sumY, degree)
  const coeffs = gaussElimination(matrix)

  // 计算多项式值
  return evaluatePolynomial(coeffs, x, degree)
}
```

### 输入验证机制

```javascript
const validateDegree = () => {
  const value = parseInt(polynomialDegree.value)
  if (isNaN(value) || value < 1) {
    polynomialDegree.value = 1
  } else if (value > 20) {
    polynomialDegree.value = 20
  } else {
    polynomialDegree.value = value
  }
}
```

### 使用建议

1. **从低次开始**：先尝试 2-3 次，观察拟合效果
2. **逐步增加**：如果拟合不佳，逐步增加次数
3. **观察警告**：注意界面上的过拟合警告
4. **数据量匹配**：确保有足够的数据点支持所选次数
5. **实验对比**：比较不同次数的拟合结果

### 扩展实验

#### 高次多项式实验

1. 添加 10-15 个规律分布的点
2. 尝试输入 10 次多项式
3. 观察是否出现过拟合和振荡
4. 对比 5 次多项式的结果

#### 数值稳定性实验

1. 添加少量点（4-5 个）
2. 尝试高次多项式（8-10 次）
3. 观察拟合结果的稳定性
4. 体验自动降级机制

这种灵活的输入方式让您可以深入探索多项式拟合的各种特性和限制！

### 特点与应用

**优点**：

- 对噪声数据有较强的鲁棒性
- 可以控制拟合函数的复杂度
- 整体拟合效果良好
- 计算稳定

**缺点**：

- 不一定通过所有数据点
- 需要预先选择拟合函数的形式
- 可能出现过拟合或欠拟合

**适用场景**：

- 数据包含噪声
- 数据点较多
- 需要平滑的趋势线
- 预测和外推

---

## 3. 两种方法的比较

### 视觉对比

在我们的演示应用中：

- 🔵 **蓝色曲线**：插值型拟合 - 精确通过所有红点
- 🟢 **绿色曲线**：逼近型拟合 - 整体趋势拟合，不一定通过所有点

### 数学特性对比

| 特性       | 插值型拟合       | 逼近型拟合                 |
| ---------- | ---------------- | -------------------------- |
| 精度       | 精确通过所有点   | 整体最优，不一定通过所有点 |
| 稳定性     | 对噪声敏感       | 对噪声鲁棒                 |
| 多项式次数 | n-1 次（n 个点） | 可控制（通常低次）         |
| 计算复杂度 | O(n²)            | O(n)                       |
| 适用数据量 | 小数据集         | 大数据集                   |

### 选择建议

**选择插值型拟合当**：

- 数据点少且精确
- 需要精确通过所有点
- 数据无噪声
- 用于精确插值计算

**选择逼近型拟合当**：

- 数据点多
- 数据包含噪声
- 需要平滑趋势
- 用于预测和分析

---

## 4. 实际应用示例

### 在计算机图形学中的应用

1. **曲线设计**：

   - 插值：精确控制关键点位置
   - 逼近：平滑的曲线外观

2. **动画插值**：

   - 关键帧之间的平滑过渡
   - 路径规划

3. **数据可视化**：
   - 散点图的趋势线
   - 数据平滑处理

### 数值分析中的应用

1. **函数逼近**：

   - 复杂函数的多项式近似
   - 数值积分

2. **数据分析**：
   - 实验数据的拟合
   - 趋势预测

---

## 5. 扩展思考

### 高级拟合方法

1. **样条插值**：分段多项式，避免高次多项式的振荡
2. **加权最小二乘**：对不同数据点赋予不同权重
3. **正则化方法**：防止过拟合
4. **非线性拟合**：拟合复杂的非线性函数

### 数值稳定性

1. **条件数**：矩阵求解的数值稳定性
2. **精度控制**：浮点数计算的误差控制
3. **算法优化**：更高效的求解算法

通过本项目的实现，您可以直观地理解这两种基础但重要的拟合方法，为进一步学习更高级的数值方法打下基础。
